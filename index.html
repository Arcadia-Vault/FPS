<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
      html, body {
        font-family: Arial, Helvetica, sans-serif;
        font-size: 20px;
        cursor: url(./cursor.png), auto !important;
      }
      * {
        cursor: url(./cursor.png), auto !important;
      }
      .scoreboard {
        position: absolute;
        background: #fff;
        width: 75px;
        height: 30px;
        padding: 5px;
        border-top-left-radius: 4px;
        border-bottom-left-radius: 4px;
        z-index: 9999;
        left: 100%;
        margin-left: -80px;
        top: 85vh;
        font-size: 12px;
        letter-spacing: 2px;
        color: #333;
        font-family: 'Courier New', Courier, monospace;
        font-weight: 600;
      }
      .ui #rounds {
        position: absolute;
        left: 50px;
        bottom: 50px;
        color: #fff;
        font-family: 'Courier New', Courier, monospace;
        letter-spacing: -2px;
        font-weight: 600;
      }
      .ui img {
        position: absolute;
        left: -35px;
        bottom: 50px;
      }
      canvas {
        background: blue;
      }
      .swal-overlay {
        background: transparent !important;
        pointer-events: none !important;
      }
      .crosshair {
        position: absolute;
        left: 50% !important;
        top: 50% !important;
        width: 25px;
        margin-left: -12.5px !important;
        margin-top: -12.5px !important;
        z-index: 9999;
        filter: invert(100%);
      }
      .health {
        position: relative;
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #fff;
      }
      .health-wrapper {
        position: absolute;
        width: 200px;
        height: 35px;
        left: 50%;
        margin-left: -100px;
        top: 20px;
        border: 2px solid #fff;
      }
      .statustext {
        position: absolute;
        left: 50%;
        width: 200px;
        top: 40%;
        margin: 0;
        padding: 0;
        margin-left: -100px;
        font-size: 18px;
        color: #fff;
      }
    </style>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Parking-Master/Gametime.js@latest/Gametime.min.js"></script>
    <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  </head>
  <body style="margin:0!important;">
    <audio id="ambience" src="https://cdn.jsdelivr.net/gh/Parking-Master/FPS/ambience.mp3" autoplay loop volume="1"></audio>
    <audio id="shot" src="https://cdn.jsdelivr.net/gh/Parking-Master/FPS/sound.mp3"></audio>
    <audio id="reload" src="https://cdn.jsdelivr.net/gh/Parking-Master/FPS/reload.mp3"></audio>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/alvaromontoro/gamecontroller.js@latest/dist/gamecontroller.min.js"></script>
    <script>
      Gamepad.Context={},Gamepad.Trigger={},Gamepad.Panel={},Gamepad.Item={},Gamepad.JoyStick={},Gamepad.JoyStick.R={},Gamepad.JoyStick.L={},Gamepad.D={},Gamepad.Context.AButtonPressed=function(){},Gamepad.onConnect=function(){},Gamepad.Context.BButtonPressed=function(){},Gamepad.Context.XButtonPressed=function(){},Gamepad.Context.YButtonPressed=function(){},Gamepad.Trigger.LeftButtonPressed=function(){},Gamepad.Trigger.RightButtonPressed=function(){},Gamepad.Panel.LeftButtonPressed=function(){},Gamepad.Panel.RightButtonPressed=function(){},Gamepad.Item.NavButtonPressed=function(){},Gamepad.Item.PauseButtonPressed=function(){},Gamepad.JoyStick.L.Pressed=function(){},Gamepad.JoyStick.R.Pressed=function(){},Gamepad.JoyStick.UpMoved=function(){},Gamepad.JoyStick.DownMoved=function(){},Gamepad.JoyStick.RightMoved=function(){},Gamepad.JoyStick.LeftMoved=function(){},Gamepad.JoyStick.UpCanceled=function(){},Gamepad.JoyStick.DownCanceled=function(){},Gamepad.JoyStick.RightCanceled=function(){},Gamepad.JoyStick.LeftCanceled=function(){},Gamepad.D.UpButtonPressed=function(){},Gamepad.D.DownButtonPressed=function(){},Gamepad.D.LeftButtonPressed=function(){},Gamepad.D.RightButtonPressed=function(){},gameControl.on("connect",(function(e){Gamepad.onConnect();for(let t=0;t<Math.min(17,e.buttons);t++)e.on("button"+t,(function(){0==t?Gamepad.Context.AButtonPressed():1==t?Gamepad.Context.BButtonPressed():2==t?Gamepad.Context.XButtonPressed():3==t?Gamepad.Context.YButtonPressed():4==t?Gamepad.Trigger.LeftButtonPressed():5==t?Gamepad.Trigger.RightButtonPressed():6==t?Gamepad.Panel.LeftButtonPressed():7==t?Gamepad.Panel.RightButtonPressed():8==t?Gamepad.Item.NavButtonPressed():9==t?Gamepad.Item.PauseButtonPressed():10==t?Gamepad.JoyStick.L.Pressed():11==t?Gamepad.JoyStick.R.Pressed():12==t?Gamepad.D.UpButtonPressed():13==t?Gamepad.D.DownButtonPressed():14==t?Gamepad.D.LeftButtonPressed():15==t&&Gamepad.D.RightButtonPressed()})).before("button"+t,()=>{}).after("button"+t,()=>{});for(let t=0;t<Math.min(2,e.axes);t++){const n=["up","down","right","left"];for(let a=0;a<n.length;a++)e.on(n[a]+t,(function(){"up"==n[a]?Gamepad.JoyStick.UpMoved():"right"==n[a]?Gamepad.JoyStick.RightMoved():"left"==n[a]?Gamepad.JoyStick.LeftMoved():"down"==n[a]&&Gamepad.JoyStick.DownMoved()})).after(n[a],()=>{n[a]=="up"?Gamepad.JoyStick.UpCanceled():n[a]=="down"?Gamepad.JoyStick.DownCanceled():n[a]=="left"?Gamepad.JoyStick.LeftCanceled():n[a]=="right"?Gamepad.JoyStick.RightCanceled():void(0)})}})).on("beforeCycle",(function(){}));
    </script>
    <div class="ui">
      <div class="scoreboard">
        <span class="player1">A: <span class="score">0</span></span>
        <hr style="margin: 0;">
        <span class="player2">B: <span class="score">0</span></span>
      </div>
      <div class="health-wrapper">
        <div class="health"></div>
      </div>
      <div class="statustext"></div>
      <img src="https://cdn.jsdelivr.net/gh/Parking-Master/FPS/sights.png" width="100%" style="display:none;position:absolute;left:50%;margin-left:-50%;bottom:0;" id="sights" />
      <img src="https://cdn.jsdelivr.net/gh/Parking-Master/FPS/handheld.png" width="15%" />
      <img class="crosshair" src="https://cdn.jsdelivr.net/gh/Parking-Master/FPS/crosshair.png" width="10%" />
      <span id="rounds"><span id="counter">10</span> &minus; <span id="magcount">10</span></span>
    </div>
    <script>
      userIds = [];
      eventsEnabled = false;
      hwalkup = 13;
      hwalkdown = 13;
      hwalkleft = 13;
      hwalkright = 13;
      zoomedInAuto = false;
      zoomedOutAuto = true;
      allowedToStart = false;
      function GameOver() {
        if ((bscore >= 3 && currentPlayer == 1) || ascore >= 3 && currentPlayer == 2) {
          swal({
            title: "Game over",
            icon: "success",
            text: "You win!"
          }).then(() => location.replace("/"));
          document.querySelector(".swal-button").style.background = "#6cc22e";
        } else {
          swal({
            title: "Game over",
            icon: "error",
            text: "You lose...",
            dangerMode: true
          }).then(() => location.replace("/"));
        }
      }
      rafex = () => {};
      function handler(e){if(eventsEnabled){return}e.stopPropagation(),e.preventDefault()}document.addEventListener("mousemove",handler,!0);
      const _euler=new THREE.Euler(0,0,0,"YXZ"),_vector=new THREE.Vector3,_changeEvent={type:"change"},_lockEvent={type:"lock"},_unlockEvent={type:"unlock"},_PI_2=Math.PI/2;class PointerLockControls extends THREE.EventDispatcher{constructor(e,t){super(),void 0===t&&(console.warn('THREE.PointerLockControls: The second parameter "domElement" is now mandatory.'),t=document.body),this.domElement=t,this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1;const o=this;function n(t){if(!1===o.isLocked)return;const n=t.movementX||t.mozMovementX||t.webkitMovementX||0,r=t.movementY||t.mozMovementY||t.webkitMovementY||0;_euler.setFromQuaternion(e.quaternion),_euler.y-=.002*n*o.pointerSpeed,_euler.x-=.002*r*o.pointerSpeed,_euler.x=Math.max(_PI_2-o.maxPolarAngle,Math.min(_PI_2-o.minPolarAngle,_euler.x)),e.quaternion.setFromEuler(_euler),o.dispatchEvent(_changeEvent)}function r(){o.domElement.ownerDocument.pointerLockElement===o.domElement?(o.dispatchEvent(_lockEvent),o.isLocked=!0):(o.dispatchEvent(_unlockEvent),o.isLocked=!1)}function c(){console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}this.connect=function(){o.domElement.ownerDocument.addEventListener("mousemove",n),o.domElement.ownerDocument.addEventListener("pointerlockchange",r),o.domElement.ownerDocument.addEventListener("pointerlockerror",c)},this.disconnect=function(){o.domElement.ownerDocument.removeEventListener("mousemove",n),o.domElement.ownerDocument.removeEventListener("pointerlockchange",r),o.domElement.ownerDocument.removeEventListener("pointerlockerror",c)},this.dispose=function(){this.disconnect()},this.getObject=function(){return e},this.getDirection=function(){const t=new THREE.Vector3(0,0,-1);return function(o){return o.copy(t).applyQuaternion(e.quaternion)}}(),this.moveForward=function(t){_vector.setFromMatrixColumn(e.matrix,0),_vector.crossVectors(e.up,_vector),e.position.addScaledVector(_vector,t)},this.moveRight=function(t){_vector.setFromMatrixColumn(e.matrix,0),e.position.addScaledVector(_vector,t)},this.lock=function(){this.domElement.requestPointerLock()},this.unlock=function(){o.domElement.ownerDocument.exitPointerLock()},this.connect()}}
      let o = setInterval(() => {
        if (userIds.length >= 2) {
          allowedToStart = true;
          return swal.close(), clearInterval(o), eventsEnabled = true;
        }
      });
      swal({
        title: "Please wait...",
        text: "Searching for players",
        buttons: false,
        closeOnEsc: false,
        closeOnClickOutside: false
      });
      shot = document.querySelector("#shot");
      sights = document.querySelector("#sights");
      reload1 = document.querySelector("#reload");
      players = 0;
      isHost = false;
      isGuest = false;
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      const geometry = new THREE.BoxGeometry(1, 3, 1);
      const groundGeometry = new THREE.BoxGeometry(200, 1, 200);
      const groundMaterial = new THREE.MeshBasicMaterial({ color: "#7ed957", map: new THREE.TextureLoader().load("https://cdn.jsdelivr.net/gh/Parking-Master/FPS/ground.png") });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      const gunGeometry = new THREE.BoxGeometry(.5, .55, 3);
      const gunHandleGeometry = new THREE.BoxGeometry(.5, .55, 1);
      const pointerge = new THREE.CircleGeometry(0.025, 32);
      const pointerma = new THREE.MeshBasicMaterial({ color: "white" });
      const material = new THREE.MeshBasicMaterial({ color: "#fff" });
      const gunMaterial = new THREE.MeshBasicMaterial({ color: "white" });
      const cube = new THREE.Mesh(geometry, material);
      const gun = new THREE.Mesh(gunGeometry, gunMaterial);
      const gunHandle = new THREE.Mesh(gunHandleGeometry, gunMaterial);
      const pointer = new THREE.Mesh(pointerge, pointerma);
      const follower = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: "white" }));
      const geometry1 = new THREE.BoxGeometry(1, 1, 1.2);
      const material1 = new THREE.MeshBasicMaterial({ color: "#eee" });
      const cube1 = new THREE.Mesh(geometry1, material1);
      const geometry2 = new THREE.BoxGeometry(.2, .4, 1.5);
      const material2 = new THREE.MeshBasicMaterial({ color: "#eee" });
      const cube2 = new THREE.Mesh(geometry2, material2);
      const geometry3 = new THREE.BoxGeometry(.2, 1.5, .4);
      const material3 = new THREE.MeshBasicMaterial({ color: "#eee" });
      const cube3 = new THREE.Mesh(geometry3, material3);
      const MapBorder = new THREE.Mesh(new THREE.TorusGeometry(30, 3, 32, 32), new THREE.MeshBasicMaterial({ color: "#999", map: new THREE.TextureLoader().load("https://raw.githubusercontent.com/Parking-Master/FPS/main/stone.png") }));
      MapBorder.rotation.x = 1.6;
      MapBorder.position.y = -2;
      var loader=new THREE.TextureLoader;loader.load("https://dm0qx8t0i9gc9.cloudfront.net/thumbnails/video/S-qZRAdPiqqgmzw2/videoblocks-a-time-lapse-of-flying-above-the-clouds_hhl8khudw_thumbnail-1080_10.png",(function(e){var a=new THREE.SphereGeometry(500,60,40),o=new THREE.MeshBasicMaterial({map:e,side:THREE.DoubleSide});a.scale(-1,1,1);var d=new THREE.Mesh(a,o);scene.add(d),d.position.set(0,0,0)}));
      renderer.setClearColor("#a6ffff");
      cube.sname = "body";
      cube1.sname = "head";
      cube2.sname = "arm";
      cube3.sname = "arm1";
      cube1.position.x = 0;
      cube1.position.y = 1.5;
      cube2.position.x = .6;
      cube2.position.y = .5;
      cube3.position.x = -.6;
      cube3.position.y = 0;
      gun.sname = "gun";
      gunHandle.sname = "gunHandle";
      scene.add(cube1);
      scene.add(follower);
      scene.add(cube2);
      scene.add(cube3);
      scene.add(ground);
      scene.add(MapBorder);
      // MapBorder.position.x = 0;
      // MapBorder.position.y = -1;
      // MapBorder.position.z = 0;
      // MapBorder.rotation.x = 1;
      ground.position.x = 0;
      ground.position.y = -4;
      ground.position.z = 0;
      clix = 0;
      cliy = 0;
      reloading = false;
      isZoomed = false;
      magcount = 10;
      player1 = [cube, cube1, cube2, cube3];
      function reload() {
        if (magcount == 0) {
          return;
        }
        if (isZoomed) {
          document.dispatchEvent(new KeyboardEvent("keydown",{key:"z"}));
        }
        reload1.currentTime = 1.2;
        reload1.play();
        reloading = true;
        magcount += -1;
        document.querySelector("#magcount").textContent = magcount;
        let t = 0;
        let h = setInterval(() => {
          if (t >= 0.2) {
            const geometry = new THREE.BoxGeometry(.25, 1, .25);
            const material = new THREE.MeshBasicMaterial({ color: "white" });
            const mag = new THREE.Mesh(geometry, material);
            mag.position.z = 1 + movY;
            mag.position.x = gunHandle.position.x;
            mag.position.y = cliy - 3 + movZ;
            mag.rotation.y = .05;
            mag.rotation.x = -.2;
            scene.add(mag);
            setTimeout(() => {
              let r = 0;
              let s = setInterval(() => {
                if (r >= .46) {
                  return (scene.remove(mag), (rounds = 10), (document.querySelector("#rounds").querySelector("#counter").textContent = rounds), gun.position.y += -2.1, gunHandle.position.y += -2.1, (reloading = false), clearInterval(s));
                }
                r += 0.05;
                mag.position.y += r;
              });
            }, 200);
            return clearInterval(h);
          }
          t += 0.01;
          gun.position.y += t;
          gunHandle.position.y += t;
        });
      }
      function createBoxWithRoundedEdges(e,t,a,n,r){let s=new THREE.Shape,b=1e-5,c=n-b;s.absarc(b,b,b,-Math.PI/2,-Math.PI,!0),s.absarc(b,t-2*c,b,Math.PI,Math.PI/2,!0),s.absarc(e-2*c,t-2*c,b,Math.PI/2,0,!0),s.absarc(e-2*c,b,b,0,-Math.PI/2,!0);let h=new THREE.ExtrudeBufferGeometry(s,{depth:a-2*n,bevelEnabled:!0,bevelSegments:2*r,steps:1,bevelSize:c,bevelThickness:n,curveSegments:r});return h.center(),h}
      cube.geometry = createBoxWithRoundedEdges(1, 2.5, 1, .25, 3);
      cube1.geometry = createBoxWithRoundedEdges(1.25, 1.25, 1, .25, 3);
      pointer.position.z = 1;
      scene.add(gun);
      scene.add(gunHandle);
      // scene.add(pointer);
      scene.add(cube);
      camera.position.z = 5;
      gun.position.z = 0.05;
      gun.position.x = 4;
      gun.position.y = -2;
      gun.rotation.y = .05;
      gunHandle.position.z = 1;
      gunHandle.position.x = 4;
      gunHandle.position.y = -2.5;
      gunHandle.rotation.x = 1;
      d = false;
      rounds = 10;
      movY = 0;
      movX = 0;
      movZ = 0;
      objects = scene.children;
      pointed = null;
      mapElements = [ground];
      bbox = null;
      setInterval(() => {
        console.info = () => {};
        players > 2 && (players = 2);
        !!otherPlayer[0] && objects.forEach(object => {
          let pointingAt = false;
          (!object.maxshot && object.maxshot != 0) && (object.maxshot = 6);
          let e=object.position.clone().project(camera);e.setZ(0),isCloseToCenter=e.length()<1;
          if (isCloseToCenter) {
            pointingAt = true;
            pointed = object;
          } else {
            pointingAt = false;
            pointed = null;
          }
        });
      });
      light=new THREE.SpotLight(16755036,4),light.position.set(0,50,0),light.castShadow=!1,scene.add(light);
      function animate() {
        requestAnimationFrame(animate);
        follower.position.set(camera.position.x,camera.position.y,camera.position.z);
        light.position.set(camera.position.x+10,camera.position.y+10,camera.position.z+10);
        // cube.rotation.y += 0.01;
        if (!d) {
          gun.position.y += 0.0025;
          gunHandle.position.y += 0.0025;
          setTimeout(() => (d = true), 2000);
        } else {
          gun.position.y += -0.0025;
          gunHandle.position.y += -0.0025;
          setTimeout(() => (d = false), 2000);
        }
        renderer.render(scene, camera);
      }
      function moveUp() {
        hwalkup = setInterval(() => {
          for(var vertexIndex=0;vertexIndex<follower.geometry.attributes.position.array.length;vertexIndex++){var localVertex=(new THREE.Vector3).fromBufferAttribute(follower.geometry.attributes.position,vertexIndex).clone(),globalVertex=localVertex.applyMatrix4(follower.matrix),directionVector=globalVertex.sub(follower.position),ray=new THREE.Raycaster(follower.position,directionVector.clone().normalize()),collisionResults=ray.intersectObjects([MapBorder].concat(otherPlayer));collisionResults.length>0&&collisionResults[0].distance<directionVector.length()&&clearInterval(hwalkup)}
          movY += -.05;
          gun.position.z += -.1;
          gunHandle.position.z += -.1;
          pointer.position.z += -.1;
          camera.position.z += -.1;
        });
      }
      function moveDown() {
        hwalkdown = setInterval(() => {
          for(var vertexIndex=0;vertexIndex<follower.geometry.attributes.position.array.length;vertexIndex++){var localVertex=(new THREE.Vector3).fromBufferAttribute(follower.geometry.attributes.position,vertexIndex).clone(),globalVertex=localVertex.applyMatrix4(follower.matrix),directionVector=globalVertex.sub(follower.position),ray=new THREE.Raycaster(follower.position,directionVector.clone().normalize()),collisionResults=ray.intersectObjects([MapBorder].concat(otherPlayer));collisionResults.length>0&&collisionResults[0].distance<directionVector.length()&&clearInterval(hwalkdown)}
          movY += .05;
          gun.position.z += .1;
          gunHandle.position.z += .1;
          pointer.position.z += .1;
          camera.position.z += .1;
        });
      }
      function moveLeft() {
        hwalkleft = setInterval(() => {
          for(var vertexIndex=0;vertexIndex<follower.geometry.attributes.position.array.length;vertexIndex++){var localVertex=(new THREE.Vector3).fromBufferAttribute(follower.geometry.attributes.position,vertexIndex).clone(),globalVertex=localVertex.applyMatrix4(follower.matrix),directionVector=globalVertex.sub(follower.position),ray=new THREE.Raycaster(follower.position,directionVector.clone().normalize()),collisionResults=ray.intersectObjects([MapBorder].concat(otherPlayer));collisionResults.length>0&&collisionResults[0].distance<directionVector.length()&&clearInterval(hwalkleft)}
          movX += -.05;
          gun.position.x += -.1;
          gunHandle.position.x += -.1;
          pointer.position.x += -.1;
          camera.position.x += -.1;
        });
      }
      function moveRight() {
        hwalkright = setInterval(() => {
          for(var vertexIndex=0;vertexIndex<follower.geometry.attributes.position.array.length;vertexIndex++){var localVertex=(new THREE.Vector3).fromBufferAttribute(follower.geometry.attributes.position,vertexIndex).clone(),globalVertex=localVertex.applyMatrix4(follower.matrix),directionVector=globalVertex.sub(follower.position),ray=new THREE.Raycaster(follower.position,directionVector.clone().normalize()),collisionResults=ray.intersectObjects([MapBorder].concat(otherPlayer));collisionResults.length>0&&collisionResults[0].distance<directionVector.length()&&clearInterval(hwalkright)}
          movX += .05;
          gun.position.x += .1;
          gunHandle.position.x += .1;
          pointer.position.x += .1;
          camera.position.x += .1;
        });
      }
      let isJumping = false;
      function jump(player) {
        if (!allowedToStart) {
          return;
        }
        gametime.run("playerJump", [currentPlayer]);
        if (isJumping) {
          return;
        }
        isJumping = true;
        let y = 0;
        let c = setInterval(() => {
          movZ += 0.005;
          if (y >= 0.1) {
            k = 0;
            let a = setInterval(() => {
              if (k >= y) {
                return clearInterval(a);
              } else {
                k += 0.005;
                gun.position.y += -k;
                gunHandle.position.y += -k;
                pointer.position.y += -k;
                camera.position.y += -k;
              }
            });
            return clearInterval(c);
          } else {
            y += 0.005;
            gun.position.y += y;
            gunHandle.position.y += y;
            pointer.position.y += y;
            camera.position.y += y;
          }
        });
        setTimeout(() => (isJumping = false), 1250);
      }
      function fire(burst) {
        if (!allowedToStart) {
          return;
        }
        if (magcount == 0 && rounds <= 0) {
          return;
        } else {
          rounds += -burst;
        }
        if (reloading) {
          return;
        }
        shot.play();
        for (let i = 0; i < burst -1; i++) {
          (function(x) {
            setTimeout(() => {
              let c = document.createElement("audio");
              c.src = shot.src;
              c.currentTime = .1;
              document.body.appendChild(c);
              c.play();
              setTimeout(() => {
                c.remove();
              }, 1000);
            }, 1000 + (70 * x));
          })(i);
        }
        bulletPositionX = gunHandle.position.x;
        (document.querySelector("#rounds").querySelector("#counter").textContent = rounds);
        let burstfire = 0;
        setInterval(() => {
        if (burstfire >= burst) {
          return;
        }
        burstfire += 1;
        const geometry = new THREE.BoxGeometry(.1, .1, .1);
        const material = new THREE.MeshBasicMaterial({ color: "white" });
        const bullet = new THREE.Mesh(geometry, material);
        const casegeometry = new THREE.BoxGeometry(.1, .1, .1);
        const casematerial = new THREE.MeshBasicMaterial({ color: "white" });
        const bcase = new THREE.Mesh(casegeometry, casematerial);
        scene.add(bullet);
        scene.add(bcase);
        bullet.position.z = movY - 2;
        bullet.position.x = bulletPositionX;
        bullet.position.y = cliy - 2 + movZ;
        bullet.rotation.y = .05;
        bcase.position.z = movY - 1;
        bcase.position.x = bulletPositionX;
        bcase.position.y = gun.position.y
        bcase.rotation.y = .05;
        setInterval(() => {
          bullet.position.z += -2;
          bcase.position.x += -.08;
          bcase.position.y += -.05;
        });
        setTimeout(() => {
          scene.remove(bullet);
          delete bullet;
          scene.remove(bcase);
          delete bcase;
        }, 200);
        }, 100);
        gun.rotation.x += 0.5;
        gunHandle.rotation.x += 0.5;
        gun.position.z += 0.25;
        gunHandle.position.z += 0.25;
        setTimeout(() => (gun.rotation.x += -0.5, gunHandle.rotation.x += -0.5, gun.position.z += -0.25, gunHandle.position.z += -0.25), 100);
        setTimeout(() => {
          if (rounds <= 0 && !reloading) {
            reload();
          }
        }, 250);
        let h = setInterval(() => {
          if (!pointed) {
            return;
          }
          let object = pointed;
          if (object.maxshot <= 0) {
            return clearInterval(h);
          }
          object.maxshot += -1;
          if (scene.children.indexOf(object) > -1) {
            gametime.run("hit", [(currentPlayer == 1 ? 2 : 1)]);
            if (object.maxshot <= 0) {
              if (object != pointer) {
                if (scene.children.indexOf(object) > -1) {
                  for (let i = 0; i < scene.children.length; i++) {
                    if (!/body|head|arm|arm1/gi.test(scene.children[i].sname)) {
                      return;
                    }
                    gametime.run("eleminate", [(currentPlayer == 1 ? 2 : 1)]);
                    scene.remove(otherPlayer[i]);
                  }
                } else {
                  scene.remove(object);
                }
              }
            } else {
              for (let i = 0; i < otherPlayer.length; i++) {
                function hexToRgb(n){if(/^#([a-f0-9]{3}){1,2}$/.test(n)){4==n.length&&(n="#"+[n[1],n[1],n[2],n[2],n[3],n[3]].join(""));var t="0x"+n.substring(1);return"rgb("+[t>>16&255,t>>8&255,255&t].join(",")+")"}}
                let unparsedColor = otherPlayer[i].material.color.getHexString();
                let currentColor = hexToRgb("#" + unparsedColor);
                const color = currentColor.replace(/^rgb[()]/gi, "").split(")").join("").split(",");
                otherPlayer[i].material.color.setRGB(255, 0, 0);
                setTimeout(() => otherPlayer[i].material.color.setRGB(color[0], color[1], color[2]), 100);
              }
            }
          }
        }, 75);
        setTimeout(() => {
          clearInterval(h);
        }, (burst.toString() + "00") - 0);
      }
      // var Tree=function(e){e=e||{},this.sections=e.sections||5,this.conesPerSection=e.conesPerSection||7,this.coneMaterial=e.coneMaterial||new THREE.MeshBasicMaterial({color:65280}),this.coneMaxRadius=e.coneMaxRadius||.7,this.coneRadiusReduction=e.coneRadiusReduction||.3,this.coneMaxLength=e.coneRadiusReduction||5,this.coneLengthReduction=e.coneLengthReduction||4.5,this.forConeValues=e.forConeValues||function(){},this.forConeMesh=e.forConeMesh||function(){},this.forSection=e.forSection||function(){},this.onDone=e.onDone||function(){},this.group=new THREE.Group;for(var t={i:0};t.i<this.sections;){var i=new THREE.Group,n={i:0};for(t.stdRadius=this.coneMaxRadius-this.coneRadiusReduction*(t.i/this.sections),t.stdLength=this.coneMaxLength-this.coneLengthReduction*(t.i/this.sections),t.radius=t.stdLength-t.stdLength/2,t.y=2*t.stdRadius*t.i,t.radOffset=t.i%2*Math.PI,this.forSection.call(this,t);n.i<this.conesPerSection;){Tree.defaultConeObj(this,n,t),this.forConeValues.call(this,n,t);var o=new THREE.ConeGeometry(n.radius,n.length,n.segRad,n.segLength,n.open,n.thetaStart,n.thetaLength),s=new THREE.Mesh(o,n.material||this.coneMaterial);s.position.set(n.x,n.y,n.z),s.rotation.set(n.r.x,n.r.y,n.r.z),this.forConeMesh.call(this,s,n,t),i.rotation.set(0,t.radOffset,0),i.add(s),n.i+=1}i.position.y=t.y,this.group.add(i),t.i+=1}this.onDone.call(this)};Tree.defaultConeObj=function(e,t,i){t.per=t.i/e.conesPerSection,t.radian=2*Math.PI*t.per,Tree.setConePos(t,i),t.r={x:Math.PI/2,y:0,z:2*Math.PI/e.conesPerSection*t.i-Math.PI/2},t.radius=i.stdRadius,t.length=i.stdLength,t.segRad=32,t.seglength=1,t.open=!1,t.thetaStart=0,t.thetaLength=2*Math.PI},Tree.setConePos=function(e,t){var i=e.radian;e.x=Math.cos(i)*t.radius,e.y=0,e.z=Math.sin(i)*t.radius};
      // var tree=new Tree({coneMaterial:new THREE.MeshStandardMaterial({color:44800}),sections:5,forConeValues:function(e,a){e.length=1,e.radius=.8-a.i/this.sections*.4;var n=e.length-.8*e.length*(a.i/this.sections);e.x=Math.cos(e.radian)*n,e.z=Math.sin(e.radian)*n}});scene.add(tree.group);
      !function(e){var t={sphere:new THREE.MeshStandardMaterial({color:65280,emissive:20224,side:THREE.DoubleSide}),trunk:new THREE.MeshStandardMaterial({color:16756480,emissive:4465152,side:THREE.DoubleSide})};e.create=function(e){(e=e||{}).trunkLength=void 0===e.trunkLength?Math.floor(Math.random() * 1.5):e.trunkLength,e.sphereSize=void 0===e.sphereSize?1:e.sphereSize,e.trunkSize=void 0===e.trunkSize?.25:e.trunkSize,e.widthSegments=void 0===e.widthSegments?15:e.widthSegments,e.heightSegments=void 0===e.heightSegments?15:e.heightSegments;var r=e.materials||t,n=new THREE.Group,i=function(e,t){var r=new THREE.Mesh(new THREE.SphereGeometry(e.sphereSize,e.widthSegments,e.heightSegments),t.sphere),n=e.trunkLength/2+.75*e.sphereSize;return r.position.set(0,0,-1*n),r}(e,r);n.add(i);var o=function(e,t){var r=new THREE.Mesh(new THREE.BoxGeometry(e.trunkSize,e.trunkLength,e.trunkSize),t.trunk);return r.position.set(0,0,0),r.rotation.set(1.57,0,0),r}(e,r);return n.add(o),n}}(this.TreeSphereMod={}),function(){for(let e=0;e<1000;e++){let e=TreeSphereMod.create({sphereSize:Math.floor(1.5*Math.random())+1,trunkLength:4});e.position.set(Math.floor(150*Math.random())-40,-2,Math.floor(150*Math.random())-40),e.lookAt(Math.floor(5*Math.random()),-40,Math.floor(5*Math.random())),scene.add(e)}}();
      animate();
      const zoomInFunction=o=>{const t=getFov();camera.fov=clickZoom(t,"zoomIn"),camera.updateProjectionMatrix()},zoomOutFunction=o=>{const t=getFov();camera.fov=clickZoom(t,"zoomOut"),camera.updateProjectionMatrix()},clickZoom=(o,t)=>o>=20&&"zoomIn"===t?o-5:o<=75&&"zoomOut"===t?o+5:o,getFov=()=>Math.floor(2*Math.atan(camera.getFilmHeight()/2/camera.getFocalLength())*180/Math.PI);
      document.addEventListener("keyup", (e) => {
        if (e.key == "ArrowUp") {
          clearInterval(hwalkup);
        } else if (e.key == "ArrowDown") {
          clearInterval(hwalkdown);
        } else if (e.key == "ArrowLeft") {
          clearInterval(hwalkleft);
        } else if (e.key == "ArrowRight") {
          clearInterval(hwalkright);
        }
      });
      document.addEventListener("keydown", (e) => {
        if (!allowedToStart) {
          return;
        }
        gametime.run("playerMove", [String(camera.position.x) + "," + String(camera.position.y) + "," + String(camera.position.z) + "," + currentPlayer]);
        if (e.key == "f" && !reloading && !e.repeat) {
          fire(2);
        }
        if (e.key == "r" && !e.repeat && rounds < 10 && !reloading) {
          reload();
        }
        if (e.key == "i" && !e.repeat && !reloading) {
          bulletPositionX = 0;
          for (let i = 0; i < 11; i++) {
            isZoomed = true;
            pointer.position.y = 5;
            zoomInFunction();
            sights.style.display = "block";
          }
        }
        if (e.key == "z" && !e.repeat && !reloading) {
          bulletPositionX = gun.position.x;
          for (let i = 0; i < 11; i++) {
            isZoomed = false;
            pointer.position.y = 0;
            zoomOutFunction();
            sights.style.display = "none";
          }
        }
        if (e.key == "ArrowUp" && !e.repeat) {
          moveUp();
        }
        if (e.key == "ArrowDown" && !e.repeat) {
          moveDown();
        }
        if (e.key == "ArrowLeft" && !e.repeat) {
          moveLeft();
        }
        if (e.key == "ArrowRight" && !e.repeat) {
          moveRight();
        }
        if (e.code == "Space" && !isJumping) {
          jump();
        }
      });
      cube.position.x = camera.position.x;
      cube.position.y = camera.position.y - 2;
      cube.position.z = camera.position.z + 1;
      cube1.position.x = camera.position.x;
      cube1.position.y = camera.position.y + 1.5 - 2;
      cube1.position.z = camera.position.z + 1;
      cube2.position.x = camera.position.x + .6;
      cube2.position.y = camera.position.y + .5 - 2;
      cube2.position.z = camera.position.z + 1;
      cube3.position.x = camera.position.x + -.6;
      cube3.position.y = camera.position.y - 2;
      cube3.position.z = camera.position.z + 1;
      document.addEventListener("mousemove", (e) => {
        gametime.run("playerRotate", [String(camera.rotation.x) + "," + String(camera.rotation.y) + "," + String(camera.rotation.z) + "," + currentPlayer]);
      });
      const controls = new PointerLockControls(camera, renderer.domElement);
      controls.isLocked = true;
      controls.pointerSpeed = 2;
      gametime.set("key", "pub-c-c44c8fc4-612e-4fc3-b875-4398f01da63c", "sub-c-b6832794-3c08-11ec-b2c1-a25c7fcd9558");
      gametime.set("channel", "all");
      gametime.make("playerMove");
      gametime.make("playerJump");
      gametime.make("playerRotate");
      gametime.make("didConnect");
      gametime.make("renderScene");
      gametime.make("isGuest");
      gametime.make("collectId");
      gametime.make("eleminate");
      gametime.make("leftGame");
      gametime.make("hit");
      let health = 100;
      statusText = document.querySelector(".statustext");
      gametime.on("hit", function(player) {
        if (player == currentPlayer) {
          health += -16.6666666666;
          document.querySelector(".health").style.width = health + "%";
          if (health <= 1) {
            gametime.run("eleminate", [currentPlayer]);
          }
        }
      });
      gametime.on("leftGame", function() {
        swal({
          icon: "info",
          title: "Warning",
          text: "One or more players have left the match. You will return to the main menu.",
          closeOnEsc: false,
          closeOnClickOutside: false
        }).then(() => {
          location.reload();
        });
      });
      ascore = 0;
      bscore = 0;
      ref = false;
      gametime.on("eleminate", function(player) {
        if (bscore >= 2 || ascore >= 2) {
          return GameOver();
        }
        if (!ref) {
          ref = true;
          player == 1 ? ascore += 1 : bscore += 1;
          document.querySelector(".player" + player).querySelector(".score").textContent = player == 1 ? ascore : bscore;
          setTimeout(() => {
            ref = false;
          }, 500);
        }
        setTimeout(() => {
          let body = otherPlayer[0];
          let head = otherPlayer[1];
          let arm = otherPlayer[2];
          let arm1 = otherPlayer[3];
          scene.add(body);
          scene.add(head);
          scene.add(arm);
          scene.add(arm1);
          body.material.color.setRGB(255, 255, 255);
          head.material.color.setRGB(238, 238, 238);
          arm.material.color.setRGB(238, 238, 238);
          arm1.material.color.setRGB(238, 238, 238);
          body.position.x = 5;
          body.position.y = 0 - 2;
          body.position.z = 5 + 1;
          head.position.x = 5;
          head.position.y = 0 + 1.5 - 2;
          head.position.z = 5 + 1;
          arm.position.x = 5 + .6;
          arm.position.y = 0 + .5 - 2;
          arm.position.z = 5 + 1;
          arm1.position.x = 5 + -.6;
          arm1.position.y = 0 - 2;
          arm1.position.z = 5 + 1;
        }, 5000);
        if (player == currentPlayer) {
          scene.remove(currentPlayer == 2 ? player2 : player1);
          document.querySelector(".ui").style.display = "none";
          swal({
            dangerMode: true,
            icon: "error",
            title: "You died!",
            text: "You will respawn in 5 seconds"
          });
          setTimeout(() => {
            ref = false;
            let body = otherPlayer[0].clone();
            let head = otherPlayer[1].clone();
            let arm = otherPlayer[2].clone();
            let arm1 = otherPlayer[3].clone();
            scene.add(body);
            scene.add(head);
            scene.add(arm);
            scene.add(arm1);
            body.material.color.setRGB(255, 255, 255);
            head.material.color.setRGB(238, 238, 238);
            arm.material.color.setRGB(238, 238, 238);
            arm1.material.color.setRGB(238, 238, 238);
            camera.position.set(0, 0, 5);
            body.position.x = 5
            body.position.y = 0 - 2;
            body.position.z = 5 + 1;
            head.position.x = 5;
            head.position.y = 0 + 1.5 - 2;
            head.position.z = 5 + 1;
            arm.position.x = 5 + .6;
            arm.position.y = 0 + .5 - 2;
            arm.position.z = 5 + 1;
            arm1.position.x = 5 + -.6;
            arm1.position.y = 0 - 2;
            arm1.position.z = 5 + 1;
            camera.rotation.set(0, 0, 0);
            swal.close();
            health = 100;
            document.querySelector(".health").style.width = health + "%";
            document.querySelector(".ui").style.display = "block";
          }, 5000);
        } else {
          statusText.textContent = "+1 kill";
          for (let i = 0; i < scene.children.length; i++) {
            /body|head|arm|arm1/gi.test(scene.children[i].sname) && scene.remove(scene.children[i]);
          }
        }
        setTimeout(() => {
          let body = otherPlayer[0];
          let head = otherPlayer[1];
          let arm = otherPlayer[2];
          let arm1 = otherPlayer[3];
          scene.add(body);
          body.position.set(0, 0, 0);
          head.position.set(0, 1.5, 0);
          arm.position.set(.6, .5, 0);
          arm1.position.set(-.6, .5, 0);
          statusText.textContent = "";
        }, 5000);
      });
      gametime.on("playerRotate", function(dir) {
        if ((dir.split(",")[3] - 0) == currentPlayer) {
          return;
        }
        for (let i = 0; i < otherPlayer.length; i++) {
          if (otherPlayer[i].sname == "head") {
            otherPlayer[i].rotation.x = dir.split(",")[0] - 1;
            otherPlayer[i].rotation.y = dir.split(",")[1] - 1;
            otherPlayer[i].rotation.z = dir.split(",")[2] - 1;
          }
        }
      });
      gametime.on("playerMove", function(dir) {
        if ((dir.split(",")[3] - 0) == currentPlayer) {
          return;
        }
        for (let i = 0; i < otherPlayer.length; i++) {
          if (otherPlayer[i].sname == "body") {
            otherPlayer[i].position.set(dir.split(",")[0] - 0, dir.split(",")[1] - 0 - 2, dir.split(",")[2] - 0);
          } else if (otherPlayer[i].sname == "head") {
            otherPlayer[i].position.set(dir.split(",")[0] - 0, dir.split(",")[1] - 0 + 1.5 - 2, dir.split(",")[2] - 0);
          } else if (otherPlayer[i].sname == "arm") {
            otherPlayer[i].position.set(dir.split(",")[0] - 0 + .6, dir.split(",")[1] - 0 + .5 - 2, dir.split(",")[2] - 0);
          } else if (otherPlayer[i].sname == "arm1") {
            otherPlayer[i].position.set(dir.split(",")[0] - 0 + -.6, dir.split(",")[1] - 0 + .5 - 2, dir.split(",")[2] - 0);
          }
          else if (otherPlayer[i].sname == "gun") {
            otherPlayer[i].position.set(dir.split(",")[0] - 0 + .6, dir.split(",")[1] - 0 + .8 - 2, dir.split(",")[2] - 0);
          }
        }
      });
      gametime.on("playerJump", function(player) {
        if (player == currentPlayer) {
          return;
        }
        let y = 0;
        let c = setInterval(() => {
          movZ += 0.005;
          if (y >= 0.1) {
            k = 0;
            let a = setInterval(() => {
              if (k >= y) {
                return clearInterval(a);
              } else {
                k += 0.005;
                for (let i = 0; i < otherPlayer.length; i++) {
                  otherPlayer[i].position.y += -k;
                }
              }
            });
            return clearInterval(c);
          } else {
            y += 0.005;
            for (let i = 0; i < otherPlayer.length; i++) {
              otherPlayer[i].position.y += y;
            }
          }
        });
      });
      willBeAutoHost = false;
      currentPlayer = 0;
      otherPlayer = [];
      userIds = [];
      gametime.on("didConnect", function() {
        gametime.run("collectId", [gametime.user.id])
        gametime.run("renderScene", [player1[0].position.x, player1[0].position.y, player1[0].position.z]);
        setInterval(() => {
          currentPlayer = (userIds[0] == gametime.user.id) ? 1 : 2;
        });
        if (willBeAutoHost) {
          isHost = true;
          isGuest = false;
          for (let i = 0; i < player1; i++) {
            player1[i].material.color.setColorName("red");
            scene.add(player1[i]);
          }
        } else {
          isHost = false;
          isGuest = true;
          player2 = player1;
          for (let i = 0; i < player2; i++) {
            player2[i].material.color.setColorName("blue");
            scene.add(player2[i]);
          }
        }
        gametime.run("isGuest");
      });
      gametime.on("isGuest", () => {
        !isHost && (currentPlayer = 2, isGuest = true, isHost = false);
      });
      gametime.on("collectId", (id) => {
        userIds.push(id);
        userIds = [... new Set(userIds)];
      })
      gametime.on("renderScene", function(x) {
        players += 1;
        setTimeout(() => {
          if (players == 1) {
            willBeAutoHost = true;
          }
        }, 0);
        for (let j = 0; j < player1.length; j++) {
          let clone = player1[j];
          for(var i=0;i<1;i++){let mesh=new THREE.Mesh(clone.geometry,clone.material);mesh.sname=clone.sname;otherPlayer.push(mesh);otherPlayer=[... new Set(otherPlayer)];mesh.position.set(clone.position.x,clone.position.y,clone.position.z),scene.add(mesh)}
        }
      });
      focused = document.hasFocus();
      gametime.onconnect = () => gametime.run("didConnect");
      window.onfocus = () => (focused = true);
      window.onblur = () => (focused = false);
      (() => {
        let ul = false;
        let al = false;
        let tl = false;
        let kl = false;
        let hl = false;
        let dl = false;
        function gameLoop(){if(!document.hasFocus()){return}(()=>{let o=navigator.getGamepads()[0];(1==o.axes[0]&&!right)?(right=true,moveRight(),gametime.run("playerMove",[String(camera.position.x)+","+String(camera.position.y)+","+String(camera.position.z)+","+currentPlayer])):(clearInterval(hwalkright),right=false),(-1==o.axes[0]&&!left)?(left=true,moveLeft(),gametime.run("playerMove",[String(camera.position.x)+","+String(camera.position.y)+","+String(camera.position.z)+","+currentPlayer])):(clearInterval(hwalkleft),left=false)})();var e=navigator.getGamepads()[0];if(e&&e.connected){e.axes;var a=e.buttons;for(var o in a){1==a[o].pressed&&((a[o]===navigator.getGamepads()[0].buttons[16]&&!ul)&&(()=>{fire(2),ul=true;let h=setInterval(()=>{if(0==a[o].pressed){clearInterval(h),ul=false}})})());1==a[o].pressed&&((a[o]===navigator.getGamepads()[0].buttons[0]&&!al)&&(()=>{jump(),al=true;let h=setInterval(()=>{if(0==a[o].pressed){clearInterval(h),al=false}})})());1==a[o].pressed&&((a[o]===navigator.getGamepads()[0].buttons[7]&&!tl)&&(()=>{reload(),tl=true;let h=setInterval(()=>{if(0==a[o].pressed){clearInterval(h),tl=false}})})())}}}var game_loop;window.addEventListener("gamepadconnected",(function(e){game_loop=setInterval(gameLoop,50)}));
        Gamepad.JoyStick.RightMoved = () => {
          if(!document.hasFocus()){return}
          if (!kl) {
            kl = true;
            gametime.run("playerMove", [String(camera.position.x) + "," + String(camera.position.y) + "," + String(camera.position.z) + "," + currentPlayer]);
            moveDown();
          }
        };
        Gamepad.JoyStick.RightCanceled = () => {
          if(!document.hasFocus()){return}
          if (kl) {
            kl = false;
            clearInterval(hwalkdown);
          }
        };
        Gamepad.JoyStick.LeftMoved = () => {
          if(!document.hasFocus()){return}
          if (!hl) {
            hl = true;
            gametime.run("playerMove", [String(camera.position.x) + "," + String(camera.position.y) + "," + String(camera.position.z) + "," + currentPlayer]);
            moveUp();
          }
        };
        Gamepad.JoyStick.LeftCanceled = () => {
          if(!document.hasFocus()){return}
          if (hl) {
            hl = false;
            clearInterval(hwalkup);
          }
        };
        Gamepad.D.LeftButtonPressed = function() {
          if(!document.hasFocus()){return}
          bulletPositionX = 0;
          if (!zoomedInAuto && !dl) {
            for (let i = 0; i < 11; i++) {
              dl = true;
              isZoomed = true;
              zoomedInAuto = true;
              pointer.position.y = 5;
              zoomInFunction();
              sights.style.display = "block";
              setTimeout(() => (dl = false), 1000);
            }
          } else if (!dl) {
            bulletPositionX = gun.position.x;
            for (let i = 0; i < 11; i++) {
              isZoomed = false;
              zoomedInAuto = false;
              pointer.position.y = 0;
              zoomOutFunction();
              sights.style.display = "none";
            }
          }
        };
        window.onbeforeunload = function(e) {
          gametime.run("leftGame");
        }
      })();
    </script>
  </body>
</html>